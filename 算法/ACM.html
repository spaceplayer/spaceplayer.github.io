<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="xinzhi">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>ACM - 新志小站</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">新志小站</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">首页 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../index.html">新志的个人小站</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">算法与数据结构 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#">算法</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../xxx">动态规划</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">题目</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="LeetCode题目总结.html">LeetCode题目总结</a>
</li>
            
<li >
    <a href="剑指offer.html">剑指offer</a>
</li>
            
<li >
    <a href="面试题总结.html">面试题总结</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">推荐系统 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../推荐系统/FM算法汇总.html">FM算法汇总</a>
</li>
                                    
<li >
    <a href="../推荐系统/深度学习召回模型.html">深度学习召回模型</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">自然语言处理 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../自然语言处理/BERT及ERNIE学习.html">预处理模型</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../xxx">机器学习</a>
                            </li>
                            <li >
                                <a href="../xxx">深度学习</a>
                            </li>
                            <li >
                                <a href="../xxx">强化学习</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">语言学习 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#">C++</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../语言/CPP笔记.html">C++笔记</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Python</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../语言/Python笔记.html">Python笔记</a>
</li>
            
<li >
    <a href="../语言/Python高效编程.md">Python高效编程</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">设计模式</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../语言/设计模式.html">设计模式</a>
</li>
    </ul>
  </li>
                                    
<li >
    <a href="../语言/多进程多线程.html">多进程多线程</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">常用工具 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../工具/如何构建自己的博客.html">如何构建自己的博客</a>
</li>
                                    
<li >
    <a href="../工具/常用Linux命令.html">常用Linux命令</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">读书笔记 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../读书笔记/论美国的民主.md">论美国的民主</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../xxx">随笔记事</a>
                            </li>
                            <li >
                                <a href="../xxx">年度计划</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li>
                                <a href="https://github.com/spaceplayer/mkdocs_blog/blob/mkdocs_blog/docs/算法/ACM.md">Edit on spaceplayer/mkdocs_blog</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#_1">对数器</a></li>
            <li><a href="#_2">步骤</a></li>
            <li><a href="#_3">注意</a></li>
            <li><a href="#_4">实现</a></li>
        <li class="main "><a href="#_5">排序</a></li>
            <li><a href="#_6">快速排序 改进版 荷兰国旗</a></li>
            <li><a href="#_7">堆排序</a></li>
            <li><a href="#_8">桶排序  (计数排序)</a></li>
        <li class="main "><a href="#_11">队列和栈</a></li>
            <li><a href="#_12">用数组结构实现大小固定的队列和栈</a></li>
            <li><a href="#_13">猫狗队列</a></li>
        <li class="main "><a href="#_15">链表题目</a></li>
            <li><a href="#ton-so1">判断链表是否回文, TO(N), SO(1)</a></li>
            <li><a href="#_16">将单向链表按某值划分成左边小、中间相等、右边大的形式</a></li>
            <li><a href="#_17">复制含有随机指针节点的链表</a></li>
            <li><a href="#_18">判断单链表是否有环</a></li>
            <li><a href="#_19">两单链表相交</a></li>
        <li class="main "><a href="#_20">二叉树题目</a></li>
            <li><a href="#_21">[福利函数] 如何直观的打印二叉树</a></li>
            <li><a href="#_22">在二叉树中找到一个结点的后继结点</a></li>
            <li><a href="#_23">二叉树的序列化和反序列化</a></li>
            <li><a href="#_25">判断一棵二叉树是否是平衡二叉树</a></li>
            <li><a href="#_26">判断一颗二叉树是否是完全二叉树</a></li>
            <li><a href="#_27">已知一棵完全二叉树,求其节点的个数</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h2 id="_1">对数器</h2>
<h3 id="_2">步骤</h3>
<ol>
<li>待测方法a</li>
<li>实现一个绝对正确但是复杂度不好的方法b,</li>
<li>实现一个随机样本产生器generateRandomArray</li>
<li>实现比对的方法</li>
<li>如果有一个样本使得比对出错,打印样本分析是哪个方法出
   错</li>
</ol>
<h3 id="_3">注意</h3>
<p>1.随机样本产生器根据题目要求(不同长度, 正负样本 0)</p>
<p>2.开始测试选择生成短数组或简单数组</p>
<p>3.准备 二叉树生成器模板 + 数组生成器模板</p>
<h3 id="_4">实现</h3>
<h4 id="java">Java实现</h4>
<pre><code class="java">    public static int[] generateRandomArray(int maxSize, int maxValue) {
            // maxSize: 数组最大范围 maxValue: 数组最大值
        // 默认生成数组包含负数
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i &lt; arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) {
            return false;
        }
        if (arr1 == null &amp;&amp; arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i &lt; arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        int testTime = 500;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i &lt; testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            bubbleSort(arr1);
            // right and slow func
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                // 打印出错的数组
                printArray(arr1);
                printArray(arr2);
                succeed = false;
                break;
            }
        }
        System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;);

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        bubbleSort(arr);
        printArray(arr);
    }
</code></pre>

<h2 id="_5">排序</h2>
<h3 id="_6">快速排序 改进版 荷兰国旗</h3>
<pre><code class="python">def partition(arr, L, R):
  &quot;&quot;&quot;
        返回最后一个元素及相等元素的左右边界
  &quot;&quot;&quot;
    less = L - 1
  # 待比较元素索引
    more = R
    while L &lt; more:
        if arr[L] &lt; arr{R}:
            less += 1
            arr[less], arr[L] = arr[L], arr[less]
            L += 1
        elif arr[L] &gt; arr[R]:
            more -= 1
            arr[more], arr[L] = arr[L], arr[more]
        else:
            L += 1
        arr[more], arr[R] = arr[R], arr[more]
        return less + 1, more

def quicksort(arr, L, R):
    if L &lt; R:
        l, r = partition(arr, L, R):
        quicksort(arr, L, l - 1)
        quicksort(arr, r + 1, R)

</code></pre>

<h3 id="_7">堆排序</h3>
<pre><code class="python">def heapify(data, index, size):
    left = index * 2 + 1
    while left &lt; size:
        largest = left + 1 if left + 1 &lt; size and data[left + 1] &gt; data[left] else left
        largest = largest if data[largest] &gt; data[index] else index
        if largest == index:
            break
        data[largest], data[index] = data[index], data[largest]
        index = largest
        left = largest * 2 + 1


def heap_sort(data):
    if not data or len(data) &lt; 2:
        return data

    n = len(data)
    # 创建堆
    for i in range((n - 1)//2, -1, -1):
        heapify(data, i, n)

    # 堆排序 
    for i in range(n-1, -1, -1):    # 从大到小
        data[0], data[i] = data[i], data[0]     # 将最后一个值与父节点交互位置
        heapify(data, 0, i)


li = list(range(10))
random.shuffle(li)
print(li)
heap_sort(li)
print(li)
</code></pre>

<pre><code class="java">
public class Code_03_HeapSort {

    public static void heapSort(int[] arr) {
        if (arr == null || arr.length &lt; 2) {
            return;
        }

        for (int i = (arr.length - 1) / 2; i &gt;= 0; i--){
            heapify(arr, i, n);
        }
        int size = arr.length;
        swap(arr, 0, --size);
        while (size &gt; 0) {
            heapify(arr, 0, size);
            swap(arr, 0, --size);
        }
    }

    public static void heapInsert(int[] arr, int index) {
        while (arr[index] &gt; arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    public static void heapify(int[] arr, int index, int size) {
        int left = index * 2 + 1;
        while (left &lt; size) {
            int largest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;
            largest = arr[largest] &gt; arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }



    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
</code></pre>

<h3 id="_8">桶排序  (计数排序)</h3>
<pre><code class="python">def bucketSort(arr):
    if not arr or len(arr) &lt; 2:
        return arr

    # 1.最大值
    maxV = max(arr)

    # 2.词频表
    bucket = [0] * (maxV + 1)
    for i in range(len(arr)):
        bucket[arr[i]] += 1
    # 3.根据词频表排序
    i = 0
    for j in range(len(bucket)):
        while bucket[j] &gt; 0:
            arr[i] = j
            i += 1
            bucket[j] -= 1

</code></pre>

<pre><code class="java">import java.util.Arrays;

class test {

    public static void bucketSort(int[] arr){
        if (arr == null || arr.length &lt; 2){
            return;
        }
        // 1.最大值
        int max = Integer.MIN_VALUE;
        for(int i = 0; i &lt; arr.length; i++){
            max = Math.max(max, arr[i]);
        }

        // 2.词频表
        int[] bucket = new int[max + 1];
        for (int i = 0; i &lt; arr.length; i++){
            bucket[arr[i]]++;
        }

        // 3.根据词频表进行安置排序
        int i = 0;
        for(int j = 0; j &lt; bucket.length; j++){
            while(bucket[j]-- &gt; 0){
                arr[i++] = j;
            }
        }
    }

</code></pre>

<h4 id="_9">热门题目</h4>
<p>给定一个数组,求如果排序之后,相邻两数的最大差值,要求时间复杂度0(N),且要求不能用非基于比较的排序。</p>
<h5 id="_10">思路</h5>
<p>1.找到最大值最小值, 构建 N + 1个桶, 把最小值放入第一个桶, 最大值放入最后一个桶</p>
<p>2.剩余N - 1个桶, 把最大值最小值的差值 (N - 1) 等分</p>
<p>3.遍历数组, 把值放入不同的范围(桶), N 个数放入 N + 1个桶一定会空余一个桶</p>
<p>4.最大差值一定在这个空桶的前一个桶最大值和后一个桶最小值</p>
<p>[注意]每个桶只更新进入这个桶的最小值和最大值, 并维护一个是否是空桶的标记</p>
<pre><code class="java">    public static int maxGap(int[] nums) {
        if (nums == null || nums.length &lt; 2) {
            return 0;
        }
        int len = nums.length;
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i &lt; len; i++) {
            min = Math.min(min, nums[i]);
            max = Math.max(max, nums[i]);
        }
        if (min == max) {
            return 0;
        }
        boolean[] hasNum = new boolean[len + 1];
        int[] maxs = new int[len + 1];
        int[] mins = new int[len + 1];
        int bid = 0;
        for (int i = 0; i &lt; len; i++) {
            bid = bucket(nums[i], len, min, max);
            mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];
            maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];
            hasNum[bid] = true;
        }
        int res = 0;
        int lastMax = maxs[0];
        int i = 1;
        for (; i &lt;= len; i++) {
            if (hasNum[i]) {
                res = Math.max(res, mins[i] - lastMax);
                lastMax = maxs[i];
            }
        }
        return res;
    }

    public static int bucket(long num, long len, long min, long max) {
        // key: 判断num属于哪个bucket 
        // (num-min)/(max-min)就是占所有的比例
        return (int) ((num - min) * len / (max - min));
    }
</code></pre>

<h2 id="_11">队列和栈</h2>
<h3 id="_12">用数组结构实现大小固定的队列和栈</h3>
<p>key: 维护一个索引</p>
<pre><code class="java">package class_03;

public class Code_01_Array_To_Stack_Queue {

    public static class ArrayStack {
        private Integer[] arr;
        private Integer size;

        public ArrayStack(int initSize) {
            if (initSize &lt; 0) {
                throw new IllegalArgumentException(&quot;The init size is less than 0&quot;);
            }
            arr = new Integer[initSize];
            size = 0;
        }

        public Integer peek() {
            if (size == 0) {
                return null;
            }
            return arr[size - 1];
        }

        public void push(int obj) {
            if (size == arr.length) {
                throw new ArrayIndexOutOfBoundsException(&quot;The queue is full&quot;);
            }
            arr[size++] = obj;
        }

        public Integer pop() {
            if (size == 0) {
                throw new ArrayIndexOutOfBoundsException(&quot;The queue is empty&quot;);
            }
            return arr[--size];
        }
    }

    public static class ArrayQueue {
        private Integer[] arr;
        private Integer size;
        private Integer first;
        private Integer last;

        public ArrayQueue(int initSize) {
            if (initSize &lt; 0) {
                throw new IllegalArgumentException(&quot;The init size is less than 0&quot;);
            }
            arr = new Integer[initSize];
            size = 0;
            first = 0;
            last = 0;
        }

        public Integer peek() {
            if (size == 0) {
                return null;
            }
            return arr[first];
        }

        public void push(int obj) {
            if (size == arr.length) {
                throw new ArrayIndexOutOfBoundsException(&quot;The queue is full&quot;);
            }
            size++;
            arr[last] = obj;
            last = last == arr.length - 1 ? 0 : last + 1;
        }

        public Integer poll() {
            if (size == 0) {
                throw new ArrayIndexOutOfBoundsException(&quot;The queue is empty&quot;);
            }
            size--;
            int tmp = first;
            first = first == arr.length - 1 ? 0 : first + 1;
            return arr[tmp];
        }
    }

    public static void main(String[] args) {

    }
}
</code></pre>

<h3 id="_13">猫狗队列</h3>
<p>实现一种狗猫队列的结构,要求如下:用户可以调用add方法将cat类或dog类的实例放入队列中;用户可以调用pollAll方法,将队列中所有的实例按照进队列的先后顺序依次弹出;用户可以调用 pol l Dog方法,将队列中dog类的实例按照进队列的先后顺序依次弹出;用户可以调用 pol ICat方法,将队列中cat类的实例按照进队列的先后顺序依次弹出;用户可以调用 isEmpty方法,检查队列中是否还有dog或cat的实例;用户可以调用 isDogEmpty方法,检查队列中是否有dog类的实例;用户可以调用 i sCatEmpty方法,检查队列中是否有cat类的实例。 </p>
<h4 id="_14">思路</h4>
<p>dog 队列</p>
<p>cat 队列</p>
<p>时间戳</p>
<h2 id="_15">链表题目</h2>
<h3 id="ton-so1">判断链表是否回文, TO(N), SO(1)</h3>
<p>快慢指针 找到中点后把后半部分逆序</p>
<h3 id="_16">将单向链表按某值划分成左边小、中间相等、右边大的形式</h3>
<p>构建指针 less eq more less_p eq_p more_p</p>
<p>重点考虑边界条件: 某区域为空</p>
<h3 id="_17">复制含有随机指针节点的链表</h3>
<h4 id="hash">双Hash</h4>
<p>不用Hash</p>
<p><img alt="image-20190823200547199" src="http://spaceplayer.oss-cn-beijing.aliyuncs.com/spaceplayer/typora_img/ACM/image-20190823200547199.png" /></p>
<h3 id="_18">判断单链表是否有环</h3>
<p>快慢指针</p>
<p>set (额外空间)</p>
<h3 id="_19">两单链表相交</h3>
<p><img alt="image-20190823204533138" src="http://spaceplayer.oss-cn-beijing.aliyuncs.com/spaceplayer/typora_img/ACM/image-20190823204533138.png" /></p>
<p>set法: 先把head1所有的结点放入set, 遍历head2是否在set中存在</p>
<p>长度法: 记录head1和head2长度, 较长的链表先走|len(head1) - len(head2) | 之后两链表一起走</p>
<p>[注]关于环: 一个有环一个无环不相交, 两个环不一样不相交 , 有一个相同的环相交(同一个入口, 两个入口)</p>
<p><img alt="image-20190824093052050" src="http://spaceplayer.oss-cn-beijing.aliyuncs.com/spaceplayer/typora_img/ACM/image-20190824093052050.png" /></p>
<pre><code class="java">    public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            this.value = data;
        }
    }

    public static Node getIntersectNode(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        Node loop1 = getLoopNode(head1);
        Node loop2 = getLoopNode(head2);
        if (loop1 == null &amp;&amp; loop2 == null) {
            return noLoop(head1, head2);
        }
        if (loop1 != null &amp;&amp; loop2 != null) {
            return bothLoop(head1, loop1, head2, loop2);
        }
        return null;
    }

    public static Node getLoopNode(Node head) {
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        Node n1 = head.next; // n1 -&gt; slow
        Node n2 = head.next.next; // n2 -&gt; fast
        while (n1 != n2) {
            if (n2.next == null || n2.next.next == null) {
                return null;
            }
            n2 = n2.next.next;
            n1 = n1.next;
        }
        n2 = head; // n2 -&gt; walk again from head
        while (n1 != n2) {
            n1 = n1.next;
            n2 = n2.next;
        }
        return n1;
    }

    public static Node noLoop(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        Node cur1 = head1;
        Node cur2 = head2;
        int n = 0;
        while (cur1.next != null) {
            n++;
            cur1 = cur1.next;
        }
        while (cur2.next != null) {
            n--;
            cur2 = cur2.next;
        }
        if (cur1 != cur2) {
            return null;
        }
        cur1 = n &gt; 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        while (n != 0) {
            n--;
            cur1 = cur1.next;
        }
        while (cur1 != cur2) {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    }

    public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
        Node cur1 = null;
        Node cur2 = null;
        if (loop1 == loop2) {
            cur1 = head1;
            cur2 = head2;
            int n = 0;
            while (cur1 != loop1) {
                n++;
                cur1 = cur1.next;
            }
            while (cur2 != loop2) {
                n--;
                cur2 = cur2.next;
            }
            cur1 = n &gt; 0 ? head1 : head2;
            cur2 = cur1 == head1 ? head2 : head1;
            n = Math.abs(n);
            while (n != 0) {
                n--;
                cur1 = cur1.next;
            }
            while (cur1 != cur2) {
                cur1 = cur1.next;
                cur2 = cur2.next;
            }
            return cur1;
        } else {
            cur1 = loop1.next;
            while (cur1 != loop1) {
                if (cur1 == loop2) {
                    return loop1;
                }
                cur1 = cur1.next;
            }
            return null;
        }
    }
</code></pre>

<h2 id="_20">二叉树题目</h2>
<p>前序中序后序</p>
<pre><code class="java">    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }

    public static void preOrderRecur(Node head) {
        if (head == null) {
            return;
        }
        System.out.print(head.value + &quot; &quot;);
        preOrderRecur(head.left);
        preOrderRecur(head.right);
    }

    public static void inOrderRecur(Node head) {
        if (head == null) {
            return;
        }
        inOrderRecur(head.left);
        System.out.print(head.value + &quot; &quot;);
        inOrderRecur(head.right);
    }

    public static void posOrderRecur(Node head) {
        if (head == null) {
            return;
        }
        posOrderRecur(head.left);
        posOrderRecur(head.right);
        System.out.print(head.value + &quot; &quot;);
    }

    public static void preOrderUnRecur(Node head) {
        System.out.print(&quot;pre-order: &quot;);
        if (head != null) {
            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
            stack.add(head);
            while (!stack.isEmpty()) {
                head = stack.pop();
                System.out.print(head.value + &quot; &quot;);
                if (head.right != null) {
                    stack.push(head.right);
                }
                if (head.left != null) {
                    stack.push(head.left);
                }
            }
        }
        System.out.println();
    }



    public static void inOrderUnRecur(Node head) {
        System.out.print(&quot;in-order: &quot;);
        if (head != null) {
            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
            while (!stack.isEmpty() || head != null) {
                if (head != null) {
                    stack.push(head);
                    head = head.left;
                } else {
                    head = stack.pop();
                    System.out.print(head.value + &quot; &quot;);
                    head = head.right;
                }
            }
        }
        System.out.println();
    }



    public static void posOrderUnRecur1(Node head) {
        System.out.print(&quot;pos-order: &quot;);
        if (head != null) {
            Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;();
            Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;();
            s1.push(head);
            while (!s1.isEmpty()) {
                head = s1.pop();
                s2.push(head);
                if (head.left != null) {
                    s1.push(head.left);
                }
                if (head.right != null) {
                    s1.push(head.right);
                }
            }
            while (!s2.isEmpty()) {
                System.out.print(s2.pop().value + &quot; &quot;);
            }
        }
        System.out.println();
    }

    public static void posOrderUnRecur1(Node head) {
        if (head == null){
            return;
        }
        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
        stack.push(head)
        Stack&lt;Node&gt; revRes = new Stack&lt;Node&gt;();
        // MRL 前序变种
        while (!stack.isEmpty()){
            head = stack.pop();
            revRes.push(head);
            if (head.left != null){
                stack.push(head.left);
            }
            if (head.right != null){
                stack.push(head.right);
            }
        }
        while (!revRes.isEmpty()){
            System.out.print(revRes.pop().value + &quot; &quot;);
        }
    }



    public static void posOrderUnRecur2(Node h) {
        System.out.print(&quot;pos-order: &quot;);
        if (h != null) {
            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
            stack.push(h);
            Node c = null;
            while (!stack.isEmpty()) {
                c = stack.peek();
                if (c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) {
                    stack.push(c.left);
                } else if (c.right != null &amp;&amp; h != c.right) {
                    stack.push(c.right);
                } else {
                    System.out.print(stack.pop().value + &quot; &quot;);
                    h = c;
                }
            }
        }
        System.out.println();
    }
</code></pre>

<h3 id="_21">[福利函数] 如何直观的打印二叉树</h3>
<p>刷题时观察树的结构</p>
<pre><code class="java">package class_04;

public class Code_02_PrintBinaryTree {

    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }

    public static void printTree(Node head) {
        System.out.println(&quot;Binary Tree:&quot;);
        printInOrder(head, 0, &quot;H&quot;, 17);
        System.out.println();
    }

    public static void printInOrder(Node head, int height, String to, int len) {
        if (head == null) {
            return;
        }
        printInOrder(head.right, height + 1, &quot;v&quot;, len);
        String val = to + head.value + to;
        int lenM = val.length();
        int lenL = (len - lenM) / 2;
        int lenR = len - lenM - lenL;
        val = getSpace(lenL) + val + getSpace(lenR);
        System.out.println(getSpace(height * len) + val);
        printInOrder(head.left, height + 1, &quot;^&quot;, len);
    }

    public static String getSpace(int num) {
        String space = &quot; &quot;;
        StringBuffer buf = new StringBuffer(&quot;&quot;);
        for (int i = 0; i &lt; num; i++) {
            buf.append(space);
        }
        return buf.toString();
    }

</code></pre>

<h3 id="_22">在二叉树中找到一个结点的后继结点</h3>
<p><img alt="image-20190824113049890" src="http://spaceplayer.oss-cn-beijing.aliyuncs.com/spaceplayer/typora_img/ACM/image-20190824113049890.png" /></p>
<p>如果该结点有右子树,那么后继结点是它的右子树的最左结点</p>
<p>如果该结点没有右子树,  那么向上查找直到找到一个根节点: 该结点是在这个根节点的左子树上, 这个点就是后继结点</p>
<p><img alt="image-20190824132855423" src="http://spaceplayer.oss-cn-beijing.aliyuncs.com/spaceplayer/typora_img/ACM/image-20190824132855423.png" /></p>
<pre><code class="java">    public static class Node {
        public int value;
        public Node left;
        public Node right;
        public Node parent;

        public Node(int data) {
            this.value = data;
        }
    }

    public static Node getSuccessorNode(Node node) {
        if (node == null) {
            return node;
        }
        if (node.right != null) {
            return getLeftMost(node.right);
        } else {
            Node parent = node.parent;
            while (parent != null &amp;&amp; parent.left != node) {
                node = parent;
                parent = node.parent;
            }
            return parent;
        }
    }

    public static Node getLeftMost(Node node) {
        if (node == null) {
            return node;
        }
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
</code></pre>

<h3 id="_23">二叉树的序列化和反序列化</h3>
<h4 id="null">先序序列化(null结点也序列化, 用#表示)</h4>
<p><img alt="image-20190824161735514" src="http://spaceplayer.oss-cn-beijing.aliyuncs.com/spaceplayer/typora_img/ACM/image-20190824161735514.png" /></p>
<p><img alt="image-20190824161813323" src="http://spaceplayer.oss-cn-beijing.aliyuncs.com/spaceplayer/typora_img/ACM/image-20190824161813323.png" /></p>
<pre><code class="java">    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }

    public static String serialByPre(Node head) {
        if (head == null) {
            return &quot;#!&quot;;
        }
        String res = head.value + &quot;!&quot;;
        res += serialByPre(head.left);
        res += serialByPre(head.right);
        return res;
    }
</code></pre>

<pre><code class="python">    def serialByPre(root):
        if not root:
            return '#_'
        res = root.val + &quot;_&quot;
        res += serialByPre(root.left)
        res += serialByPre(root.right)
        return res


  def reconByPreString(preStr):
        values = preStr.split(&quot;_&quot;)
        # 逆序目的方便取出
        stack = valueOf[::-1]
        return _reconPreOrder(stack);

    def _reconPreOrder(stack):
        val = stack.pop()
        if val == '#':
            return
        root = Node(int(val))
        root.left = _reconPreOrder(stack)
        root.right = _reconPreOrder(stack)
        return root
</code></pre>

<h4 id="_24">层次遍历序列化及反序列化</h4>
<pre><code class="java">    public static String serialByLevel(Node head) {
        if (head == null) {
            return &quot;#!&quot;;
        }
        String res = head.value + &quot;!&quot;;
        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
        queue.offer(head);
        while (!queue.isEmpty()) {
            head = queue.poll();
            if (head.left != null) {
                res += head.left.value + &quot;!&quot;;
                queue.offer(head.left);
            } else {
                res += &quot;#!&quot;;
            }
            if (head.right != null) {
                res += head.right.value + &quot;!&quot;;
                queue.offer(head.right);
            } else {
                res += &quot;#!&quot;;
            }
        }
        return res;
    }



    public static Node reconByLevelString(String levelStr) {
        String[] values = levelStr.split(&quot;!&quot;);
        int index = 0;
        Node head = generateNodeByString(values[index++]);
        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
        if (head != null) {
            queue.offer(head);
        }
        Node node = null;
        while (!queue.isEmpty()) {
            node = queue.poll();
            node.left = generateNodeByString(values[index++]);
            node.right = generateNodeByString(values[index++]);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        return head;
    }


    public static Node generateNodeByString(String val) {
        if (val.equals(&quot;#&quot;)) {
            return null;
        }
        return new Node(Integer.valueOf(val));
    }
</code></pre>

<pre><code class="python">    def serialByLevel(root):
        if not root:
            return &quot;#_&quot;
        res = root.val
        que = queue.Queue()
        que.put(root)
        while queue:
            root = queue.poll()
            if head.left:
                res += root.left.val + &quot;_&quot;
            else:
                res += &quot;#_&quot;
            if head.right:
                res += root.right.val + &quot;_&quot;
            else:
                res += &quot;#_&quot;
        return res

    def generateNodeByString(val):
        if val == '#':
            return
        return Node(int(val))

    def _reconByLevelString(levelStr):
        values = levelStr.split(&quot;_&quot;)
        index = 0
        root = generateNodeByString(valueOf[index])
        index += 1
        que = queue()
        if root:
            queue.put(root)
        node = None
        while !que.empty():
            node = que.get()
            node.left = _reconByLevelString(values[index])
            index += 1
            node.right = _reconByLevelString(values[index])
            index += 1
            if node.left:
                que.put(node.left)
            if node.right:
                que.put(node.right)
        return root

</code></pre>

<h3 id="_25">判断一棵二叉树是否是平衡二叉树</h3>
<p>自底向上 helper返回深度</p>
<h3 id="_26">判断一颗二叉树是否是完全二叉树</h3>
<p>若左结点有空有节点不为空返回false</p>
<p>then 如果左结点不空右结点空或左右均为空那么后面必须均是叶节点(层次遍历)</p>
<pre><code class="java">    public static boolean isCBT(Node head) {
        if (head == null) {
            return true;
        }
        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
        boolean leaf = false;
        Node l = null;
        Node r = null;
        queue.offer(head);
        while (!queue.isEmpty()) {
            head = queue.poll();
            l = head.left;
            r = head.right;
            if ((leaf &amp;&amp; (l != null || r != null)) || (l == null &amp;&amp; r != null)) {
                return false;
            }
            if (l != null) {
                queue.offer(l);
            }
            if (r != null) {
                queue.offer(r);
            } else {
                leaf = true;
            }
        }
        return true;
    }
</code></pre>

<h3 id="_27">已知一棵完全二叉树,求其节点的个数</h3>
<p>要求:时间复杂度低于0(N),N为这棵树的节点个数</p>
<p>低于O(N) 不能遍历求结点个数</p>
<p>1.遍历左结点 计算高度 mostLeftLevel</p>
<p>2.遍历右子树的左结点判断是否到达最底层</p>
<p>​   2.1如果到达最底层, 左子树是满二叉树, 递归调用右子树</p>
<p>​   2.2如果没到到最底层,右子树是满二叉树, 递归调用左子树</p>
<pre><code class="java">    public static int nodeNum(Node head) {
        if (head == null) {
            return 0;
        }
        return bs(head, 1, mostLeftLevel(head, 1));
    }

    public static int bs(Node node, int l, int h) {
        if (l == h) {
            return 1;
        }
        if (mostLeftLevel(node.right, l + 1) == h) {
            return (1 &lt;&lt; (h - l)) + bs(node.right, l + 1, h);
        } else {
            return (1 &lt;&lt; (h - l - 1)) + bs(node.left, l + 1, h);
        }
    }

    public static int mostLeftLevel(Node node, int level) {
        while (node != null) {
            level++;
            node = node.left;
        }
        return level - 1;
    }
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
